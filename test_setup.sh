#!/bin/bash
# TEST MODE - No actual installations, only config validation

echo "=========================================="
echo "CONVERXA SETUP TEST MODE - $(date)"
echo "=========================================="
echo "‚ö†Ô∏è  MODO PRUEBA - No se realizar√°n instalaciones reales"
echo "‚úÖ Solo se validar√°n configuraciones de Nginx"
echo ""

# Crear directorios de prueba para nginx
mkdir -p /tmp/nginx-test/sites-available
mkdir -p /tmp/nginx-test/sites-enabled

echo "üîÑ PASO 1/12: Simulando actualizaci√≥n del sistema..."
echo "‚úÖ [SIMULADO] Sistema actualizado correctamente"

echo "üîÑ PASO 2/12: Simulando instalaci√≥n de dependencias..."
echo "‚úÖ [SIMULADO] Dependencias b√°sicas instaladas"

echo "üîÑ PASO 3/12: Simulando instalaci√≥n de Docker..."
echo "‚úÖ [SIMULADO] Docker instalado correctamente"

echo "üîÑ PASO 4/12: Simulando configuraci√≥n de Docker..."
echo "‚úÖ [SIMULADO] Docker configurado y habilitado"

echo "üîÑ PASO 5/12: Simulando instalaci√≥n de Nginx..."
echo "‚úÖ [SIMULADO] Nginx instalado y configurado"

echo "üîÑ PASO 6/12: Simulando instalaci√≥n de PostgreSQL..."
echo "‚úÖ [SIMULADO] PostgreSQL instalado correctamente"

echo "‚úÖ [SIMULADO] pgvector instalado correctamente"

echo "‚úÖ [SIMULADO] Firewall configurado"
echo "‚úÖ [SIMULADO] SSH verificado"


echo "‚úÖ [SIMULADO] SSH configurado y verificado"

echo "üîÑ PASO 8/12: Configurando Nginx para Blue-Green deployment..."
# Configurar Nginx para Blue-Green deployment (configuraci√≥n inicial para Blue)
cat > /tmp/nginx-test/sites-available/backend.conf << 'EOL'
# Configuraci√≥n para HTTPS (backend)
server {
    listen 443 ssl;
    server_name back-chat.converxa.com;

    # Certificados SSL
    ssl_certificate /etc/letsencrypt/live/back-chat.converxa.com/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/back-chat.converxa.com/privkey.pem; # managed by Certbot
    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot

    location / {
        proxy_pass http://localhost:3002;  # Redirige al backend Blue por defecto
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Configuraci√≥n para WebSockets (WSS)
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_cache_bypass $http_upgrade;

        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;

        # Headers adicionales
        proxy_set_header X-Deployment-Color "blue";
    }

    # Health check endpoint
    location /health {
        proxy_pass http://localhost:3002/api/health;
        proxy_set_header Host $host;
        access_log off;
    }
}

# Redirecci√≥n de HTTP a HTTPS (backend)
server {
    listen 80;
    server_name back-chat.converxa.com;

    # Redirige todo el tr√°fico HTTP a HTTPS
    return 301 https://$host$request_uri;
}
EOL

# Simular habilitaci√≥n de sitios
ln -sf /tmp/nginx-test/sites-available/backend.conf /tmp/nginx-test/sites-enabled/backend.conf

# Verificar configuraci√≥n de Nginx (TEST MODE)
echo "üîç Validando sintaxis del archivo de configuraci√≥n..."
if command -v nginx >/dev/null 2>&1; then
    echo "‚úÖ Nginx est√° instalado, validando configuraci√≥n..."
    if nginx -t -c /tmp/nginx-test/sites-available/backend.conf 2>/dev/null; then
        echo "‚úÖ Configuraci√≥n de Nginx v√°lida"
    else
        echo "‚ùå Error en configuraci√≥n de Nginx:"
        nginx -t -c /tmp/nginx-test/sites-available/backend.conf
        echo "üîß Revisando sintaxis manualmente..."
    fi
else
    echo "‚ö†Ô∏è  Nginx no instalado, validando sintaxis b√°sica..."
    if [ -f /tmp/nginx-test/sites-available/backend.conf ]; then
        echo "‚úÖ Archivo de configuraci√≥n creado correctamente"
        echo "üìÑ Contenido del archivo:"
        head -20 /tmp/nginx-test/sites-available/backend.conf
    else
        echo "‚ùå Error: No se pudo crear el archivo de configuraci√≥n"
    fi
fi

echo "‚úÖ [SIMULADO] Certbot instalado"

echo "‚úÖ Nginx configurado para Blue-Green deployment"

echo "üîÑ PASO 9/12: Simulando creaci√≥n de directorios..."
echo "‚úÖ [SIMULADO] Directorios del proyecto creados"
mkdir -p /var/log/sofia-chat/frontend
mkdir -p /root/repos

# Instalar scripts Blue-Green permanentemente
cat > /opt/sofia-chat/blue-green-simple.sh << 'BLUE_GREEN_SCRIPT_EOF'
#!/bin/bash

# Script simplificado para Blue-Green Deployment
# Uso: ./blue-green-simple.sh [status|deploy|switch|rollback]

set -e

PROJECT_DIR="/root/repos/sofia-chat-backend-v2"
STATE_FILE="/opt/.blue-green-state"

# Detect environment and use appropriate docker-compose file
if [ -f "$PROJECT_DIR/docker-compose.prod.yml" ] && [ "$NODE_ENV" = "production" ]; then
    DOCKER_COMPOSE="docker-compose -f docker-compose.prod.yml"
    echo "Using production docker-compose configuration"
else
    DOCKER_COMPOSE="docker-compose -f docker-compose.yml"
    echo "Using development docker-compose configuration"
fi

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Funci√≥n para logging
log() {
    echo -e "$${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1$${NC}"
}

warn() {
    echo -e "$${YELLOW}[WARNING] $1$${NC}"
}

error() {
    echo -e "$${RED}[ERROR] $1$${NC}"
    exit 1
}

# Obtener el estado actual
get_current_state() {
    if [ -f "$STATE_FILE" ]; then
        cat "$STATE_FILE"
    else
        echo "blue"
    fi
}

# Guardar el estado
save_state() {
    echo "$1" > "$STATE_FILE"
}

# Verificar si un contenedor est√° corriendo
is_container_running() {
    local container_name="$1"
    docker ps --format "table {{.Names}}" | grep -q "^$container_name$"
}

# Actualizar configuraci√≥n de nginx para apuntar al slot correcto
update_nginx_config() {
    local target_color="$1"
    local target_port=""

    if [ "$target_color" = "blue" ]; then
        target_port="3002"
    else
        target_port="3003"
    fi

    log "Actualizando configuraci√≥n de nginx para $target_color (puerto $target_port)..."

    # Usar el script de actualizaci√≥n de producci√≥n
    if [ -f "/opt/sofia-chat/scripts/update-prod-config.sh" ]; then
        /opt/sofia-chat/scripts/update-prod-config.sh "$target_color" || {
            error "Error al actualizar configuraci√≥n de nginx"
        }
        log "‚úÖ Configuraci√≥n de nginx actualizada"
    else
        warn "Script de actualizaci√≥n de nginx no encontrado - switch solo cambi√≥ estado interno"
    fi
}

# Backup del estado actual y base de datos antes de hacer cambios cr√≠ticos
backup_state() {
    local backup_file="$PROJECT_DIR/.blue-green-backup"
    local current_state=$(get_current_state)

    log "Creando backup del estado actual y base de datos..."

    # Remover backup anterior si existe
    rm -f "$backup_file"
    rm -f "$PROJECT_DIR/db-backup.sql"

    # Backup de estado
    cat > "$backup_file" << EOF
TIMESTAMP=$(date)
CURRENT_STATE=$current_state
BLUE_RUNNING=$(is_container_running "sofia-chat-backend-blue" && echo "yes" || echo "no")
GREEN_RUNNING=$(is_container_running "sofia-chat-backend-green" && echo "yes" || echo "no")
EOF

    # Backup de base de datos usando variables del archivo .env
    local db_backup_file="$PROJECT_DIR/db-backup.sql"

    if [ -f "$PROJECT_DIR/.env" ]; then
        log "Cargando variables de entorno desde .env..."

        # Cargar variables de base de datos desde .env
        export $(grep -E '^TYPEORM_(HOST|PORT|USERNAME|PASSWORD|DB_NAME)=' "$PROJECT_DIR/.env" | xargs)

        if [ -n "$TYPEORM_HOST" ] && [ -n "$TYPEORM_USERNAME" ] && [ -n "$TYPEORM_DB_NAME" ]; then
            log "Creando backup de base de datos desde $TYPEORM_HOST..."
            log "Base de datos: $TYPEORM_DB_NAME"
            log "Usuario: $TYPEORM_USERNAME"

            # Crear backup usando pg_dump
            PGPASSWORD="$TYPEORM_PASSWORD" pg_dump \
                -h "$TYPEORM_HOST" \
                -p "$TYPEORM_PORT" \
                -U "$TYPEORM_USERNAME" \
                -d "$TYPEORM_DB_NAME" \
                > "$db_backup_file" 2>/dev/null

            if [ $? -eq 0 ] && [ -s "$db_backup_file" ]; then
                log "‚úÖ Backup de DB guardado exitosamente en: $db_backup_file"
                local backup_size=$(du -h "$db_backup_file" | cut -f1)
                log "üìä Tama√±o del backup: $backup_size"
                echo "DB_BACKUP_FILE=$db_backup_file" >> "$backup_file"
            else
                warn "‚ùå No se pudo crear backup de base de datos o el archivo est√° vac√≠o"
                rm -f "$db_backup_file"
            fi
        else
            warn "‚ùå Variables de base de datos incompletas en .env"
        fi

        # Limpiar variables de entorno
        unset TYPEORM_HOST TYPEORM_PORT TYPEORM_USERNAME TYPEORM_PASSWORD TYPEORM_DB_NAME
    else
        warn "‚ùå Archivo .env no encontrado - saltando backup de DB"
    fi

    log "‚úÖ Backup de estado guardado en: $backup_file"
}

# Restaurar base de datos desde backup
restore_database() {
    local db_backup_file="$PROJECT_DIR/db-backup.sql"

    if [ ! -f "$db_backup_file" ]; then
        error "‚ùå Archivo de backup no encontrado: $db_backup_file"
    fi

    if [ ! -f "$PROJECT_DIR/.env" ]; then
        error "‚ùå Archivo .env no encontrado"
    fi

    warn "‚ö†Ô∏è  ADVERTENCIA: Esto sobrescribir√° la base de datos actual"
    log "Archivo de backup: $db_backup_file"

    # Cargar variables de base de datos desde .env
    export $(grep -E '^TYPEORM_(HOST|PORT|USERNAME|PASSWORD|DB_NAME)=' "$PROJECT_DIR/.env" | xargs)

    if [ -n "$TYPEORM_HOST" ] && [ -n "$TYPEORM_USERNAME" ] && [ -n "$TYPEORM_DB_NAME" ]; then
        log "Restaurando base de datos en $TYPEORM_HOST..."
        log "Base de datos: $TYPEORM_DB_NAME"
        log "Usuario: $TYPEORM_USERNAME"

        # Restaurar usando psql
        PGPASSWORD="$TYPEORM_PASSWORD" psql \
            -h "$TYPEORM_HOST" \
            -p "$TYPEORM_PORT" \
            -U "$TYPEORM_USERNAME" \
            -d "$TYPEORM_DB_NAME" \
            < "$db_backup_file" 2>/dev/null

        if [ $? -eq 0 ]; then
            log "‚úÖ Base de datos restaurada exitosamente"
        else
            error "‚ùå Error al restaurar la base de datos"
        fi
    else
        error "‚ùå Variables de base de datos incompletas en .env"
    fi

    # Limpiar variables de entorno
    unset TYPEORM_HOST TYPEORM_PORT TYPEORM_USERNAME TYPEORM_PASSWORD TYPEORM_DB_NAME
}

# Health check de un contenedor
health_check() {
    local container_name="$1"
    local port="$2"
    local max_attempts=30
    local attempt=1

    log "Verificando salud de $container_name en puerto $port..."

    while [ $attempt -le $max_attempts ]; do
        # Intentar con wget primero, luego con nc
        if command -v wget >/dev/null 2>&1; then
            if wget -q --spider "http://localhost:$port/api/health" 2>/dev/null; then
                log "‚úÖ $container_name est√° saludable"
                return 0
            fi
        elif command -v nc >/dev/null 2>&1; then
            if echo -e "GET /api/health HTTP/1.1\r\nHost: localhost\r\n\r\n" | nc localhost $port | grep -q "200 OK"; then
                log "‚úÖ $container_name est√° saludable"
                return 0
            fi
        else
            # Fallback: verificar si el contenedor est√° corriendo
            if is_container_running "$container_name"; then
                log "‚úÖ $container_name est√° corriendo (health check b√°sico)"
                return 0
            fi
        fi

        echo -n "."
        sleep 2
        attempt=$((attempt + 1))
    done

    error "‚ùå $container_name no respondi√≥ en $max_attempts intentos"
}

# Mostrar estado actual
show_status() {
    local current_state=$(get_current_state)

    echo "=================================="
    echo "   ESTADO BLUE-GREEN DEPLOYMENT"
    echo "=================================="
    echo "Estado actual: $current_state"
    echo ""

    # Verificar contenedores
    if is_container_running "sofia-chat-backend-blue"; then
        echo "üîµ Blue (puerto 3002): RUNNING"
    else
        echo "üîµ Blue (puerto 3002): STOPPED"
    fi

    if is_container_running "sofia-chat-backend-green"; then
        echo "üü¢ Green (puerto 3003): RUNNING"
    else
        echo "üü¢ Green (puerto 3003): STOPPED"
    fi

    echo "üóÑÔ∏è  Database: External PostgreSQL (not managed)"

    echo "=================================="
}

# Deploy a slot espec√≠fico
deploy() {
    local current_state=$(get_current_state)
    local target_slot=""

    # Determinar slot objetivo
    if [ "$current_state" = "blue" ]; then
        target_slot="green"
    else
        target_slot="blue"
    fi

    log "Desplegando a slot: $target_slot"
    log "Slot actual en producci√≥n: $current_state"

    cd "$PROJECT_DIR"

    log "DEBUG: Verificando archivos docker-compose..."
    ls -la docker-compose*.yml

    log "DEBUG: Verificando servicios disponibles..."
    AVAILABLE_SERVICES=$($DOCKER_COMPOSE config --services)
    echo "Servicios disponibles: $AVAILABLE_SERVICES"

    # Detener y remover contenedor existente si est√° corriendo
    if is_container_running "sofia-chat-backend-$target_slot"; then
        log "Deteniendo contenedor existente: sofia-chat-backend-$target_slot"
        $DOCKER_COMPOSE stop sofia-chat-backend-$target_slot
        $DOCKER_COMPOSE rm -f sofia-chat-backend-$target_slot
    fi

    # Build de la nueva imagen con --no-cache para garantizar imagen fresca
    log "Construyendo nueva imagen..."
    $DOCKER_COMPOSE build --no-cache sofia-chat-backend-$target_slot

    # Deploy al slot objetivo usando nueva imagen
    if [ "$target_slot" = "green" ]; then
        log "Desplegando a Green (puerto 3003)..."
        log "DEBUG: Comando a ejecutar: $DOCKER_COMPOSE --profile green up -d sofia-chat-backend-green"
        $DOCKER_COMPOSE --profile green up -d sofia-chat-backend-green
    else
        log "Desplegando a Blue (puerto 3002)..."
        log "DEBUG: Comando a ejecutar: $DOCKER_COMPOSE up -d sofia-chat-backend-blue"
        $DOCKER_COMPOSE up -d sofia-chat-backend-blue
    fi

    # Verificar salud del nuevo deployment
    if [ "$target_slot" = "green" ]; then
        health_check "sofia-chat-backend-green" "3003"
    else
        health_check "sofia-chat-backend-blue" "3002"
    fi

    log "‚úÖ Deployment a $target_slot completado exitosamente"
    log "üß™ Puedes probar el nuevo deployment en puerto $([ "$target_slot" = "green" ] && echo "3003" || echo "3002")"
    log "‚ö†Ô∏è  Para hacer switch a producci√≥n, ejecuta: ./blue-green-simple.sh switch"
}

# Hacer switch entre blue y green
switch() {
    local current_state=$(get_current_state)
    local new_state=""

    if [ "$current_state" = "blue" ]; then
        new_state="green"
        local new_port="3003"
    else
        new_state="blue"
        local new_port="3002"
    fi

    # Verificar que el nuevo slot est√© corriendo y saludable
    if ! is_container_running "sofia-chat-backend-$new_state"; then
        error "El contenedor sofia-chat-backend-$new_state no est√° corriendo. Ejecuta deploy primero."
    fi

    log "Verificando salud del nuevo slot antes del switch..."
    health_check "sofia-chat-backend-$new_state" "$new_port"

    # Crear backup antes del switch
    backup_state

    # Hacer el switch
    log "Cambiando de $current_state a $new_state..."
    save_state "$new_state"

    # Actualizar configuraci√≥n de nginx
    update_nginx_config "$new_state"

    log "‚úÖ Switch completado: $new_state ahora est√° en producci√≥n"
    log "üîÑ Para hacer rollback, ejecuta: ./blue-green-simple.sh rollback"
}

# Rollback al estado anterior
rollback() {
    local current_state=$(get_current_state)
    local rollback_state=""
    local rollback_port=""

    if [ "$current_state" = "blue" ]; then
        rollback_state="green"
        rollback_port="3003"
    else
        rollback_state="blue"
        rollback_port="3002"
    fi

    warn "Haciendo rollback de $current_state a $rollback_state..."

    # Cambiar al directorio del proyecto
    cd "$PROJECT_DIR" || error "No se pudo cambiar al directorio $PROJECT_DIR"

    # Verificar que el rollback slot est√© disponible
    if ! is_container_running "sofia-chat-backend-$rollback_state"; then
        error "‚ùå El contenedor $rollback_state no est√° disponible para rollback"
    fi

    # Verificar salud del rollback slot
    health_check "sofia-chat-backend-$rollback_state" "$rollback_port"

    # Hacer rollback
    save_state "$rollback_state"

    # Actualizar configuraci√≥n de nginx
    update_nginx_config "$rollback_state"

    log "‚úÖ Rollback completado: $current_state ‚Üí $rollback_state"
    log "üîó Estado restaurado: $rollback_state (puerto $rollback_port)"
}

# Limpiar slot inactivo
cleanup() {
    log "=== INICIANDO CLEANUP ==="

    # Determinar qu√© est√° realmente en producci√≥n (via Nginx)
    local nginx_config="/etc/nginx/sites-available/backend.conf"
    log "Verificando configuraci√≥n de Nginx en: $nginx_config"

    if [[ ! -f "$nginx_config" ]]; then
        error "Archivo de configuraci√≥n de Nginx no encontrado: $nginx_config"
    fi

    local prod_port=$(grep -o "localhost:[0-9]*" "$nginx_config" | head -1 | cut -d: -f2)
    log "Puerto detectado en Nginx: $prod_port"

    local prod_state
    local inactive_state

    if [[ "$prod_port" == "3002" ]]; then
        prod_state="blue"
        inactive_state="green"
    elif [[ "$prod_port" == "3003" ]]; then
        prod_state="green"
        inactive_state="blue"
    else
        error "No se pudo determinar el estado de producci√≥n desde puerto: $prod_port"
    fi

    log "Producci√≥n est√° en: $prod_state (puerto $prod_port)"
    log "Limpiando entorno inactivo: $inactive_state"

    local container_name="sofia-chat-backend-$inactive_state"
    log "Contenedor a eliminar: $container_name"

    # Verificar que el contenedor existe
    if ! docker ps -a --format '{{.Names}}' | grep -q "^$${container_name}$"; then
        log "El contenedor $container_name no existe"
        log "Contenedores existentes:"
        docker ps -a --format 'table {{.Names}}\t{{.Status}}'
        log "Cleanup completado - contenedor ya no existe"
        return 0
    fi

    if is_container_running "$container_name"; then
        log "Deteniendo contenedor de pruebas: $container_name"

        if ! docker stop "$container_name"; then
            error "Error al detener el contenedor $container_name"
        fi

        log "Contenedor detenido, procediendo a eliminar..."

        if ! docker rm "$container_name"; then
            error "Error al eliminar el contenedor $container_name"
        fi

        log "Contenedor $container_name eliminado exitosamente"
    else
        log "El contenedor $container_name ya est√° detenido, elimin√°ndolo..."

        if ! docker rm "$container_name"; then
            error "Error al eliminar el contenedor detenido $container_name"
        fi

        log "Contenedor detenido $container_name eliminado"
    fi

    # Limpiar im√°genes no utilizadas
    log "Limpiando im√°genes no utilizadas..."
    docker image prune -f

    log "=== CLEANUP COMPLETADO ==="
    log "Solo queda $prod_state en producci√≥n"

    # Verificaci√≥n final
    log "Contenedores restantes:"
    docker ps --format 'table {{.Names}}\t{{.Status}}'
}

# Funci√≥n principal
main() {
    case "$${1:-status}" in
        "status"|"s")
            show_status
            ;;
        "deploy"|"d")
            deploy
            ;;
        "switch"|"sw")
            switch
            ;;
        "rollback"|"rb")
            rollback
            ;;
        "cleanup"|"clean")
            cleanup
            ;;
        "restore")
            restore_database
            ;;
        "help"|"h"|"-h"|"--help")
            echo "Uso: $0 [comando] [par√°metros]"
            echo ""
            echo "Comandos:"
            echo "  status              - Mostrar estado actual (default)"
            echo "  deploy              - Desplegar a slot inactivo"
            echo "  switch              - Cambiar tr√°fico al nuevo slot"
            echo "  rollback            - Volver al slot anterior"
            echo "  cleanup             - Limpiar slot inactivo"
            echo "  restore             - Restaurar DB desde √∫ltimo backup"
            echo "  help                - Mostrar esta ayuda"
            echo ""
            echo "Ejemplos:"
            echo "  $0 restore"
            ;;
        *)
            error "Comando desconocido: $1. Usa 'help' para ver opciones disponibles."
            ;;
    esac
}

# Ejecutar funci√≥n principal
main "$@"
BLUE_GREEN_SCRIPT_EOF

# Instalar script de actualizaci√≥n de configuraci√≥n de producci√≥n
cat > /opt/sofia-chat/scripts/update-prod-config.sh << 'UPDATE_PROD_SCRIPT_EOF'
#!/bin/bash

# Script para actualizar la configuraci√≥n de producci√≥n de Nginx
# Actualiza el upstream de producci√≥n para apuntar al color especificado

set -e

# Configuraci√≥n
TARGET_COLOR="$1"
NGINX_CONFIG_DIR="/etc/nginx/sites-available"
CONFIG_FILE="$NGINX_CONFIG_DIR/backend.conf"

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() {
    echo -e "$${GREEN}[INFO]$${NC} $1"
}

log_error() {
    echo -e "$${RED}[ERROR]$${NC} $1"
}

# Validar par√°metros
if [[ -z "$TARGET_COLOR" ]]; then
    log_error "Uso: $0 {blue|green}"
    exit 1
fi

if [[ "$TARGET_COLOR" != "blue" && "$TARGET_COLOR" != "green" ]]; then
    log_error "Color debe ser 'blue' o 'green'"
    exit 1
fi

# Determinar puerto seg√∫n color
# Blue=3002, Green=3003
if [[ "$TARGET_COLOR" == "blue" ]]; then
    TARGET_PORT="3002"
    INTERNAL_PORT="3003"  # Puerto inactivo para pruebas internas
else
    TARGET_PORT="3003"
    INTERNAL_PORT="3002"  # Puerto inactivo para pruebas internas
fi

# Detectar entorno para logging
if [ -f "/root/repos/sofia-chat-backend-v2/docker-compose.prod.yml" ] && [ "$NODE_ENV" = "production" ]; then
    log_info "Entorno: PRODUCCI√ìN"
else
    log_info "Entorno: DESARROLLO"
fi

log_info "Actualizando configuraci√≥n de nginx para apuntar a $TARGET_COLOR (puerto $TARGET_PORT)"

# Crear configuraci√≥n de Nginx para producci√≥n
cat > "$CONFIG_FILE" << EOL
# Configuraci√≥n para HTTPS (backend)
server {
    listen 443 ssl;
    server_name back-chat.converxa.com;

    # Certificados SSL
    ssl_certificate /etc/letsencrypt/live/back-chat.converxa.com/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/back-chat.converxa.com/privkey.pem; # managed by Certbot
    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot

    location / {
        proxy_pass http://localhost:$TARGET_PORT;  # Redirige al backend $TARGET_COLOR
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;

        # Configuraci√≥n para WebSockets (WSS)
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_cache_bypass \$http_upgrade;

        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;

        # Headers adicionales
        proxy_set_header X-Deployment-Color $TARGET_COLOR;
    }

    # Health check endpoint
    location /health {
        proxy_pass http://localhost:$TARGET_PORT/api/health;
        proxy_set_header Host \$host;
        access_log off;
    }
}

# Redirecci√≥n de HTTP a HTTPS (backend)
server {
    listen 80;
    server_name back-chat.converxa.com;

    # Redirige todo el tr√°fico HTTP a HTTPS
    return 301 https://\$host\$request_uri;
}

# Configuraci√≥n para HTTPS (internal testing)
server {
    listen 443 ssl;
    server_name internal-back-chat.converxa.com;

    # Certificados SSL
    ssl_certificate /etc/letsencrypt/live/internal-back-chat.converxa.com/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/internal-back-chat.converxa.com/privkey.pem; # managed by Certbot
    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot

    location / {
        proxy_pass http://localhost:$INTERNAL_PORT;  # Redirige al backend inactivo para pruebas
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;

        # Configuraci√≥n para WebSockets (WSS)
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_cache_bypass \$http_upgrade;

        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;

        # Headers adicionales
        proxy_set_header X-Deployment-Color $([ "$TARGET_COLOR" = "blue" ] && echo "green" || echo "blue");
        proxy_set_header X-Environment "internal-testing";
    }

    # Health check endpoint
    location /health {
        proxy_pass http://localhost:$INTERNAL_PORT/api/health;
        proxy_set_header Host \$host;
        access_log off;
    }
}

# Redirecci√≥n de HTTP a HTTPS (internal testing)
server {
    listen 80;
    server_name internal-back-chat.converxa.com;

    # Redirige todo el tr√°fico HTTP a HTTPS
    return 301 https://\$host\$request_uri;
}
EOL

log_info "Configuraci√≥n de nginx actualizada exitosamente"
log_info "Nginx ahora apunta a: $TARGET_COLOR (puerto $TARGET_PORT)"

# Verificar configuraci√≥n
if nginx -t; then
    log_info "Configuraci√≥n de Nginx v√°lida"

    # Recargar nginx para aplicar cambios
    if systemctl reload nginx; then
        log_info "Nginx recargado exitosamente"
    else
        log_error "Error al recargar Nginx"
        exit 1
    fi
else
    log_error "Error en configuraci√≥n de Nginx"
    exit 1
fi
UPDATE_PROD_SCRIPT_EOF

# Crear script de build del frontend
cat > /opt/sofia-chat/scripts/frontend-build.sh << 'FRONTEND_BUILD_SCRIPT_EOF'
#!/bin/bash

# Script para buildear el frontend para diferentes entornos
# Uso: ./frontend-build.sh [prod|internal]

set -e

ENVIRONMENT="$1"
FRONTEND_DIR="/root/repos/sofia-chat-frontend-v2"
BUILD_DIR=""
API_URL=""

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log() {
    echo -e "$${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1$${NC}"
}

error() {
    echo -e "$${RED}[ERROR] $1$${NC}"
    exit 1
}

# Validar par√°metros
if [[ -z "$ENVIRONMENT" ]]; then
    error "Uso: $0 {prod|internal}"
fi

# Configurar seg√∫n entorno
case "$ENVIRONMENT" in
    "prod")
        BUILD_DIR="/var/www/frontend/prod"
        API_URL="https://back-chat.converxa.com"
        log "Buildeando frontend para PRODUCCI√ìN"
        ;;
    "internal")
        BUILD_DIR="/var/www/frontend/internal"
        API_URL="https://internal-back-chat.converxa.com"
        log "Buildeando frontend para PRUEBAS INTERNAS"
        ;;
    *)
        error "Entorno debe ser 'prod' o 'internal'"
        ;;
esac

log "API URL: $API_URL"
log "Build Directory: $BUILD_DIR"

# Verificar que el directorio del frontend existe
if [[ ! -d "$FRONTEND_DIR" ]]; then
    error "Directorio del frontend no encontrado: $FRONTEND_DIR"
fi

cd "$FRONTEND_DIR"

# Crear archivo .env para el build
cat > .env << ENV_EOF
VITE_API_URL=$API_URL
VITE_ENVIRONMENT=$ENVIRONMENT
VITE_BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
ENV_EOF

log "Instalando dependencias..."
npm install

log "Buildeando aplicaci√≥n..."
npm run build

# Limpiar directorio de destino
log "Limpiando directorio de destino..."
rm -rf "$BUILD_DIR"/*

# Copiar archivos buildeados
log "Copiando archivos buildeados..."
cp -r dist/* "$BUILD_DIR"/

# Configurar permisos
chown -R www-data:www-data "$BUILD_DIR"
chmod -R 755 "$BUILD_DIR"

log "‚úÖ Build completado exitosamente para $ENVIRONMENT"
log "üìÅ Archivos en: $BUILD_DIR"
log "üìä Tama√±o: $(du -sh "$BUILD_DIR" | cut -f1)"

# Verificar archivos cr√≠ticos
if [[ -f "$BUILD_DIR/index.html" ]]; then
    log "‚úÖ index.html encontrado"
else
    error "‚ùå index.html no encontrado en el build"
fi

log "üåê El frontend estar√° disponible en:"
if [[ "$ENVIRONMENT" == "prod" ]]; then
    log "   https://app-chat.converxa.com"
else
    log "   https://internal-app.converxa.com"
fi
FRONTEND_BUILD_SCRIPT_EOF

# Crear script de deploy del frontend
cat > /opt/sofia-chat/scripts/frontend-deploy.sh << 'FRONTEND_DEPLOY_SCRIPT_EOF'
#!/bin/bash

# Script para deploy completo del frontend
# Actualiza repositorio y rebuilds ambos entornos

set -e

FRONTEND_DIR="/root/repos/sofia-chat-frontend-v2"
BACKEND_DIR="/root/repos/sofia-chat-backend-v2"

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log() {
    echo -e "$${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1$${NC}"
}

error() {
    echo -e "$${RED}[ERROR] $1$${NC}"
    exit 1
}

warn() {
    echo -e "$${YELLOW}[WARNING] $1$${NC}"
}

log "=== INICIANDO DEPLOY DEL FRONTEND ==="

# Clonar/actualizar frontend si no existe
if [[ ! -d "$FRONTEND_DIR" ]]; then
    log "Clonando repositorio del frontend..."
    cd /root/repos
    git clone https://github.com/your-org/sofia-chat-frontend-v2.git
    cd "$FRONTEND_DIR"
else
    log "Actualizando repositorio del frontend..."
    cd "$FRONTEND_DIR"
    git fetch origin
    git checkout main || git checkout master || git checkout develop
    git pull
fi

log "Commit actual del frontend: $(git rev-parse --short HEAD)"

# Build para producci√≥n
log "=== BUILDING FRONTEND PARA PRODUCCI√ìN ==="
/opt/sofia-chat/scripts/frontend-build.sh prod

# Build para pruebas internas
log "=== BUILDING FRONTEND PARA PRUEBAS INTERNAS ==="
/opt/sofia-chat/scripts/frontend-build.sh internal

# Actualizar configuraci√≥n de Nginx para incluir frontend
log "=== ACTUALIZANDO CONFIGURACI√ìN DE NGINX ==="
/opt/sofia-chat/scripts/update-nginx-full.sh

log "‚úÖ Deploy del frontend completado exitosamente"
log ""
log "üåê URLs disponibles:"
log "   Producci√≥n: https://app-chat.converxa.com"
log "   Pruebas: https://internal-app.converxa.com"
log ""
log "üìä Estado de archivos:"
ls -la /var/www/frontend/
FRONTEND_DEPLOY_SCRIPT_EOF

# Crear script de configuraci√≥n completa de Nginx
cat > /opt/sofia-chat/scripts/update-nginx-full.sh << 'NGINX_FULL_SCRIPT_EOF'
#!/bin/bash

# Script para actualizar la configuraci√≥n completa de Nginx (Backend + Frontend)

set -e

NGINX_CONFIG_DIR="/etc/nginx/sites-available"
BACKEND_CONFIG="$NGINX_CONFIG_DIR/backend.conf"
FRONTEND_CONFIG="$NGINX_CONFIG_DIR/frontend.conf"

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m'

log_info() {
    echo -e "$${GREEN}[INFO]$${NC} $1"
}

log_error() {
    echo -e "$${RED}[ERROR]$${NC} $1"
}

# Obtener estado actual del Blue-Green
CURRENT_STATE=$(cat /opt/.blue-green-state 2>/dev/null || echo "blue")

if [[ "$CURRENT_STATE" == "blue" ]]; then
    BACKEND_PORT="3002"
    INTERNAL_BACKEND_PORT="3003"
else
    BACKEND_PORT="3003"
    INTERNAL_BACKEND_PORT="3002"
fi

log_info "Estado Blue-Green actual: $CURRENT_STATE"
log_info "Puerto de producci√≥n: $BACKEND_PORT"
log_info "Puerto de pruebas internas: $INTERNAL_BACKEND_PORT"

# Crear configuraci√≥n de Frontend
cat > "$FRONTEND_CONFIG" << 'FRONTEND_NGINX_EOF'
# Configuraci√≥n para Frontend Producci√≥n
server {
    listen 443 ssl;
    server_name app-chat.converxa.com;

    # Certificados SSL
    ssl_certificate /etc/letsencrypt/live/app-chat.converxa.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/app-chat.converxa.com/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    # Directorio ra√≠z del frontend de producci√≥n
    root /var/www/frontend/prod;
    index index.html;

    # Configuraci√≥n para SPA (Single Page Application)
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Cache para assets est√°ticos
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # Headers de seguridad
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    # Logs espec√≠ficos
    access_log /var/log/nginx/frontend-prod-access.log;
    error_log /var/log/nginx/frontend-prod-error.log;
}

# Redirecci√≥n HTTP a HTTPS para Frontend Producci√≥n
server {
    listen 80;
    server_name app-chat.converxa.com;
    return 301 https://$host$request_uri;
}

# Configuraci√≥n para Frontend Pruebas Internas
server {
    listen 443 ssl;
    server_name internal-app.converxa.com;

    # Certificados SSL
    ssl_certificate /etc/letsencrypt/live/internal-app.converxa.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/internal-app.converxa.com/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    # Directorio ra√≠z del frontend de pruebas
    root /var/www/frontend/internal;
    index index.html;

    # Configuraci√≥n para SPA
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Cache para assets est√°ticos
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1h;  # Cache menor para pruebas
        add_header Cache-Control "public";
    }

    # Headers de seguridad
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-Environment "internal-testing" always;

    # Logs espec√≠ficos
    access_log /var/log/nginx/frontend-internal-access.log;
    error_log /var/log/nginx/frontend-internal-error.log;
}

# Redirecci√≥n HTTP a HTTPS para Frontend Pruebas
server {
    listen 80;
    server_name internal-app.converxa.com;
    return 301 https://$host$request_uri;
}
FRONTEND_NGINX_EOF

# Actualizar configuraci√≥n de Backend (usando el script existente)
/opt/sofia-chat/scripts/update-prod-config.sh "$CURRENT_STATE"

# Habilitar configuraci√≥n de frontend
ln -sf "$FRONTEND_CONFIG" /etc/nginx/sites-enabled/frontend.conf

log_info "Configuraci√≥n de Frontend creada: $FRONTEND_CONFIG"
log_info "Configuraci√≥n de Backend actualizada para: $CURRENT_STATE"

# Verificar configuraci√≥n
if nginx -t; then
    log_info "Configuraci√≥n de Nginx v√°lida"

    # Recargar nginx
    if systemctl reload nginx; then
        log_info "Nginx recargado exitosamente"
        log_info "‚úÖ Configuraci√≥n completa aplicada"
    else
        log_error "Error al recargar Nginx"
        exit 1
    fi
else
    log_error "Error en configuraci√≥n de Nginx"
    exit 1
fi

log_info "üåê URLs configuradas:"
log_info "   Backend Prod: https://back-chat.converxa.com"
log_info "   Backend Internal: https://internal-back-chat.converxa.com"
log_info "   Frontend Prod: https://app-chat.converxa.com"
log_info "   Frontend Internal: https://internal-app.converxa.com"
NGINX_FULL_SCRIPT_EOF

# Hacer scripts ejecutables
chmod +x /opt/sofia-chat/blue-green-simple.sh
chmod +x /opt/sofia-chat/scripts/update-prod-config.sh
chmod +x /opt/sofia-chat/scripts/frontend-build.sh
chmod +x /opt/sofia-chat/scripts/frontend-deploy.sh
chmod +x /opt/sofia-chat/scripts/update-nginx-full.sh

# Crear aliases para facilitar el uso
cat >> /root/.bashrc << 'ALIASES_EOF'

# Blue-Green Deployment Aliases
alias bg-status='/opt/sofia-chat/blue-green-simple.sh status'
alias bg-deploy='/opt/sofia-chat/blue-green-simple.sh deploy'
alias bg-switch='/opt/sofia-chat/blue-green-simple.sh switch'
alias bg-rollback='/opt/sofia-chat/blue-green-simple.sh rollback'
alias bg-cleanup='/opt/sofia-chat/blue-green-simple.sh cleanup'
alias bg-logs='docker logs -f'
alias bg-health='curl -s http://localhost:3002/api/health && echo "" && curl -s http://localhost:3003/api/health'

# Frontend Deployment Aliases
alias frontend-deploy='/opt/sofia-chat/scripts/frontend-deploy.sh'
alias frontend-build-prod='/opt/sofia-chat/scripts/frontend-build.sh prod'
alias frontend-build-internal='/opt/sofia-chat/scripts/frontend-build.sh internal'
alias frontend-status='ls -la /var/www/frontend/'
ALIASES_EOF

echo "‚úÖ [SIMULADO] Certificados SSL configurados"
echo "‚úÖ [SIMULADO] Estado Blue-Green inicializado"

# Configurar permisos para logs
echo "‚úÖ [SIMULADO] Permisos de logs configurados"

echo "‚úÖ [SIMULADO] curl instalado"

echo "üîÑ PASO 10/12: Simulando instalaci√≥n de Node.js..."
echo "‚úÖ [SIMULADO] Node.js y npm instalados correctamente"

echo "üîÑ PASO 11/12: Validando configuraci√≥n adicional de Nginx..."
# Validar configuraci√≥n de Nginx para pruebas internas
cat > /tmp/nginx-test/sites-available/internal-backend.conf << 'INTERNAL_EOL'
# Configuraci√≥n placeholder para pruebas internas
# Se actualizar√° din√°micamente por los scripts de Blue-Green
server {
    listen 80;
    server_name internal-back-chat.converxa.com;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl;
    server_name internal-back-chat.converxa.com;

    # Usar los mismos certificados por ahora
    ssl_certificate /etc/letsencrypt/live/back-chat.converxa.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/back-chat.converxa.com/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    location / {
        proxy_pass http://localhost:3001;  # Inicialmente apunta a blue
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Headers para identificar entorno de pruebas
        proxy_set_header X-Environment internal-testing;
        add_header X-Internal-Testing "true" always;
        add_header X-Deployment-Color "blue" always;

        # Configuraci√≥n para WebSockets
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_cache_bypass $http_upgrade;
    }
}
INTERNAL_EOL

# Configurar logrotate para logs de Blue-Green
cat > /etc/logrotate.d/sofia-chat << 'LOGROTATE_EOL'
/var/log/sofia-chat/*/*.log {
    daily
    missingok
    rotate 30
    compress
    notifempty
    create 644 www-data www-data
    sharedscripts
    postrotate
        systemctl reload nginx > /dev/null 2>&1 || true
    endscript
}
LOGROTATE_EOL

echo "‚úÖ [SIMULADO] Configuraci√≥n de Nginx y scripts completada"

# Validar segunda configuraci√≥n de Nginx
echo "üîç Validando configuraci√≥n interna de Nginx..."
if command -v nginx >/dev/null 2>&1; then
    if nginx -t -c /tmp/nginx-test/sites-available/internal-backend.conf 2>/dev/null; then
        echo "‚úÖ Configuraci√≥n interna de Nginx v√°lida"
    else
        echo "‚ùå Error en configuraci√≥n interna de Nginx:"
        nginx -t -c /tmp/nginx-test/sites-available/internal-backend.conf
    fi
else
    echo "‚ö†Ô∏è  Nginx no instalado, archivo creado en: /tmp/nginx-test/sites-available/internal-backend.conf"
fi

echo "‚úÖ [SIMULADO] Nginx reiniciado"

echo "‚úÖ [SIMULADO] Crontab configurado para renovaci√≥n SSL"

# Crear script de health check autom√°tico
cat > /opt/sofia-chat/scripts/health-check.sh << 'HEALTH_CHECK_SCRIPT_EOF'
#!/bin/bash

# Script de health check para Blue-Green deployment
# Monitorea la salud de ambos contenedores y el estado del sistema

set -e

LOG_FILE="/var/log/sofia-chat/health-check.log"
STATE_FILE="/opt/.blue-green-state"

# Funci√≥n de logging
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# Verificar salud de un contenedor
check_container_health() {
    local container_name="$1"
    local port="$2"

    if docker ps --format "table {{.Names}}" | grep -q "^$container_name$"; then
        if wget -q --spider --timeout=5 "http://localhost:$port/api/health" 2>/dev/null; then
            echo "HEALTHY"
        else
            echo "UNHEALTHY"
        fi
    else
        echo "STOPPED"
    fi
}

# Funci√≥n principal de health check
main() {
    case "$${1:-check}" in
        "check")
            local current_state=$(cat "$STATE_FILE" 2>/dev/null || echo "blue")
            local blue_health=$(check_container_health "sofia-chat-backend-blue" "3002")
            local green_health=$(check_container_health "sofia-chat-backend-green" "3003")

            log "Estado actual: $current_state | Blue: $blue_health | Green: $green_health"

            # Alertar si el contenedor en producci√≥n no est√° saludable
            if [ "$current_state" = "blue" ] && [ "$blue_health" != "HEALTHY" ]; then
                log "ALERTA: Contenedor Blue en producci√≥n no est√° saludable"
            elif [ "$current_state" = "green" ] && [ "$green_health" != "HEALTHY" ]; then
                log "ALERTA: Contenedor Green en producci√≥n no est√° saludable"
            fi
            ;;
        "monitor")
            log "Iniciando monitoreo continuo..."
            while true; do
                main check
                sleep 30
            done
            ;;
        *)
            echo "Uso: $0 [check|monitor]"
            exit 1
            ;;
    esac
}

main "$@"
HEALTH_CHECK_SCRIPT_EOF

# Hacer ejecutable el script de health check
chmod +x /opt/sofia-chat/scripts/health-check.sh

# Configurar health check autom√°tico cada 5 minutos
(crontab -l 2>/dev/null; echo "*/5 * * * * /opt/sofia-chat/scripts/health-check.sh check >> /var/log/sofia-chat/health-check.log 2>&1") | crontab -

# Validaci√≥n final del setup
echo "=== VALIDACI√ìN FINAL DEL SETUP ==="

# Verificar servicios cr√≠ticos
echo "Verificando servicios cr√≠ticos..."
systemctl is-active --quiet docker && echo "‚úÖ Docker: ACTIVO" || echo "‚ùå Docker: INACTIVO"
systemctl is-active --quiet nginx && echo "‚úÖ Nginx: ACTIVO" || echo "‚ùå Nginx: INACTIVO"
systemctl is-active --quiet postgresql && echo "‚úÖ PostgreSQL: ACTIVO" || echo "‚ùå PostgreSQL: INACTIVO"
systemctl is-active --quiet ssh && echo "‚úÖ SSH: ACTIVO" || echo "‚ùå SSH: INACTIVO"

# Verificar scripts Blue-Green
echo ""
echo "Verificando scripts Blue-Green..."
if [ -f "/opt/sofia-chat/blue-green-simple.sh" ] && [ -x "/opt/sofia-chat/blue-green-simple.sh" ]; then
    echo "‚úÖ Script principal: INSTALADO"
else
    echo "‚ùå Script principal: ERROR"
fi

if [ -f "/opt/sofia-chat/scripts/update-prod-config.sh" ] && [ -x "/opt/sofia-chat/scripts/update-prod-config.sh" ]; then
    echo "‚úÖ Script de configuraci√≥n: INSTALADO"
else
    echo "‚ùå Script de configuraci√≥n: ERROR"
fi

if [ -f "/opt/sofia-chat/scripts/health-check.sh" ] && [ -x "/opt/sofia-chat/scripts/health-check.sh" ]; then
    echo "‚úÖ Script de health check: INSTALADO"
else
    echo "‚ùå Script de health check: ERROR"
fi

# Verificar configuraci√≥n de Nginx
echo ""
echo "Verificando configuraci√≥n de Nginx..."
if nginx -t &>/dev/null; then
    echo "‚úÖ Configuraci√≥n de Nginx: V√ÅLIDA"
else
    echo "‚ùå Configuraci√≥n de Nginx: ERROR"
fi

# Verificar aliases
echo ""
echo "Verificando aliases..."
if grep -q "bg-status" /root/.bashrc; then
    echo "‚úÖ Aliases Blue-Green: CONFIGURADOS"
else
    echo "‚ùå Aliases Blue-Green: ERROR"
fi

# Verificar crontab
echo ""
echo "Verificando crontab..."
if crontab -l | grep -q "health-check.sh"; then
    echo "‚úÖ Health check autom√°tico: CONFIGURADO"
else
    echo "‚ùå Health check autom√°tico: ERROR"
fi

# Verificar directorios
echo ""
echo "Verificando directorios..."
for dir in "/var/log/sofia-chat/blue" "/var/log/sofia-chat/green" "/var/log/sofia-chat/nginx" "/opt/sofia-chat/scripts" "/var/www/frontend/prod" "/var/www/frontend/internal"; do
    if [ -d "$dir" ]; then
        echo "‚úÖ Directorio $(basename $dir): CREADO"
    else
        echo "‚ùå Directorio $(basename $dir): ERROR"
    fi
done

# Verificar scripts de frontend
echo ""
echo "Verificando scripts de frontend..."
if [ -f "/opt/sofia-chat/scripts/frontend-build.sh" ] && [ -x "/opt/sofia-chat/scripts/frontend-build.sh" ]; then
    echo "‚úÖ Script de build frontend: INSTALADO"
else
    echo "‚ùå Script de build frontend: ERROR"
fi

if [ -f "/opt/sofia-chat/scripts/frontend-deploy.sh" ] && [ -x "/opt/sofia-chat/scripts/frontend-deploy.sh" ]; then
    echo "‚úÖ Script de deploy frontend: INSTALADO"
else
    echo "‚ùå Script de deploy frontend: ERROR"
fi

if [ -f "/opt/sofia-chat/scripts/update-nginx-full.sh" ] && [ -x "/opt/sofia-chat/scripts/update-nginx-full.sh" ]; then
    echo "‚úÖ Script de Nginx completo: INSTALADO"
else
    echo "‚ùå Script de Nginx completo: ERROR"
fi

# Verificar Node.js
echo ""
echo "Verificando Node.js..."
if command -v node >/dev/null 2>&1; then
    echo "‚úÖ Node.js: $(node --version)"
else
    echo "‚ùå Node.js: NO INSTALADO"
fi

if command -v npm >/dev/null 2>&1; then
    echo "‚úÖ npm: $(npm --version)"
else
    echo "‚ùå npm: NO INSTALADO"
fi

# Verificar estado inicial
echo ""
echo "Verificando estado inicial..."
if [ -f "/opt/.blue-green-state" ]; then
    echo "‚úÖ Estado inicial: $(cat /opt/.blue-green-state)"
else
    echo "‚ùå Estado inicial: ERROR"
fi

echo ""
echo "üéâ PASO 12/12: FINALIZACI√ìN"
echo "=========================================="
echo "‚úÖ MODO PRUEBA COMPLETADO EXITOSAMENTE"
echo "=========================================="
echo "Validaci√≥n del script de setup Converxa completada"

echo ""
echo "üìã RESUMEN DE VALIDACI√ìN:"
echo "‚úÖ Configuraciones de Nginx creadas en /tmp/nginx-test/"
echo "‚úÖ Archivos de configuraci√≥n validados"
if [ -f /tmp/nginx-test/sites-available/backend.conf ]; then
    echo "‚úÖ backend.conf: $(wc -l < /tmp/nginx-test/sites-available/backend.conf) l√≠neas"
fi
if [ -f /tmp/nginx-test/sites-available/internal-backend.conf ]; then
    echo "‚úÖ internal-backend.conf: $(wc -l < /tmp/nginx-test/sites-available/internal-backend.conf) l√≠neas"
fi

echo ""
echo "üîß Para revisar las configuraciones:"
echo "  cat /tmp/nginx-test/sites-available/backend.conf"
echo "  cat /tmp/nginx-test/sites-available/internal-backend.conf"
echo "IMPORTANTE: Scripts Blue-Green instalados en /opt/sofia-chat/"
echo "IMPORTANTE: DNS debe configurarse manualmente para back-chat.converxa.com"
echo "IMPORTANTE: DNS debe configurarse manualmente para internal-back-chat.converxa.com"
echo "Luego ejecutar: certbot --nginx -d internal-back-chat.converxa.com"
echo ""
echo "Comandos Backend disponibles:"
echo "  bg-status    - Ver estado actual"
echo "  bg-deploy    - Deploy a color inactivo"
echo "  bg-switch    - Cambiar tr√°fico al otro color"
echo "  bg-rollback  - Rollback al color anterior"
echo "  bg-cleanup   - Limpiar contenedores parados"
echo ""
echo "Comandos Frontend disponibles:"
echo "  frontend-deploy      - Deploy del frontend"
echo "  frontend-status      - Ver estado de archivos"
echo ""
echo "URLs Backend disponibles:"
echo "  - Producci√≥n: https://back-chat.converxa.com"
echo "  - Pruebas internas: https://internal-back-chat.converxa.com"
echo "  - Blue directo: http://$(curl -s ifconfig.me):3002/api/health"
echo "  - Green directo: http://$(curl -s ifconfig.me):3003/api/health"
echo ""
echo "URLs Frontend disponibles (despu√©s del deploy):"
echo "  - Producci√≥n: https://app-chat.converxa.com"
echo "  - Pruebas internas: https://internal-app.converxa.com"
echo ""
echo "NOTA: Para deployar el frontend ejecutar:"
echo "  1. Configurar certificados SSL para dominios frontend"
echo "  2. frontend-deploy"
echo "=========================================="

# Mark test as complete
echo "Test completed successfully at $(date)" > /tmp/test_complete
echo "üéâ MODO PRUEBA FINALIZADO EXITOSAMENTE - $(date)"
